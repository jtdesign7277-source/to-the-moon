"""
Base Strategy Class
Abstract base class that all strategy types inherit from
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from typing import Dict, List, Optional, Any
from enum import Enum
import uuid


class SignalType(Enum):
    """Trading signal types"""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"
    EXIT = "exit"


class PositionSide(Enum):
    """Position sides"""
    LONG = "long"  # Betting YES
    SHORT = "short"  # Betting NO
    NONE = "none"


@dataclass
class Signal:
    """Trading signal generated by a strategy"""
    signal_type: SignalType
    market_id: str
    platform: str
    confidence: float  # 0-1 confidence score
    price: float
    side: PositionSide
    size_recommendation: float  # Recommended position size (0-1 of max)
    reason: str
    timestamp: datetime = field(default_factory=datetime.utcnow)
    metadata: Dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> Dict:
        return {
            'signal_type': self.signal_type.value,
            'market_id': self.market_id,
            'platform': self.platform,
            'confidence': self.confidence,
            'price': self.price,
            'side': self.side.value,
            'size_recommendation': self.size_recommendation,
            'reason': self.reason,
            'timestamp': self.timestamp.isoformat(),
            'metadata': self.metadata,
        }


@dataclass
class Position:
    """Represents an open position"""
    id: str
    market_id: str
    platform: str
    side: PositionSide
    entry_price: float
    current_price: float
    size: float
    entry_time: datetime
    unrealized_pnl: float = 0.0
    realized_pnl: float = 0.0
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    trailing_stop: Optional[float] = None
    trailing_stop_trigger: Optional[float] = None
    metadata: Dict[str, Any] = field(default_factory=dict)

    def update_price(self, new_price: float):
        """Update position with new price"""
        self.current_price = new_price
        if self.side == PositionSide.LONG:
            self.unrealized_pnl = (new_price - self.entry_price) * self.size
        else:
            self.unrealized_pnl = (self.entry_price - new_price) * self.size

    def get_pnl_percent(self) -> float:
        """Get P&L as percentage"""
        if self.entry_price == 0:
            return 0
        if self.side == PositionSide.LONG:
            return ((self.current_price - self.entry_price) / self.entry_price) * 100
        else:
            return ((self.entry_price - self.current_price) / self.entry_price) * 100

    def to_dict(self) -> Dict:
        return {
            'id': self.id,
            'market_id': self.market_id,
            'platform': self.platform,
            'side': self.side.value,
            'entry_price': self.entry_price,
            'current_price': self.current_price,
            'size': self.size,
            'entry_time': self.entry_time.isoformat(),
            'unrealized_pnl': self.unrealized_pnl,
            'realized_pnl': self.realized_pnl,
            'stop_loss': self.stop_loss,
            'take_profit': self.take_profit,
            'trailing_stop': self.trailing_stop,
            'pnl_percent': self.get_pnl_percent(),
        }


@dataclass
class StrategyConfig:
    """Configuration for a strategy"""
    strategy_type: str
    name: str
    markets: List[str]  # Platform IDs: ['kalshi', 'manifold']
    categories: List[str]  # Market categories: ['politics', 'crypto']

    # Position sizing
    min_edge: float = 2.0  # Minimum edge % to enter
    max_position: float = 100.0  # Max position size in dollars
    kelly_fraction: float = 0.25  # Kelly criterion fraction
    min_liquidity: float = 10000  # Minimum market liquidity

    # Exit conditions
    stop_loss: float = 10.0  # Stop loss %
    take_profit: float = 15.0  # Take profit %
    trailing_stop: Optional[float] = None  # Trailing stop %
    time_exit_hours: Optional[float] = None  # Exit after X hours

    # Advanced exit conditions
    advanced_exit_conditions: Dict[str, Any] = field(default_factory=dict)
    conditional_rules: List[Dict[str, Any]] = field(default_factory=list)

    # Strategy-specific settings
    custom_settings: Dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> Dict:
        return {
            'strategy_type': self.strategy_type,
            'name': self.name,
            'markets': self.markets,
            'categories': self.categories,
            'min_edge': self.min_edge,
            'max_position': self.max_position,
            'kelly_fraction': self.kelly_fraction,
            'min_liquidity': self.min_liquidity,
            'stop_loss': self.stop_loss,
            'take_profit': self.take_profit,
            'trailing_stop': self.trailing_stop,
            'time_exit_hours': self.time_exit_hours,
            'advanced_exit_conditions': self.advanced_exit_conditions,
            'conditional_rules': self.conditional_rules,
            'custom_settings': self.custom_settings,
        }


class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies.

    Each strategy must implement:
    - analyze(): Analyze markets and generate signals
    - should_enter(): Determine if conditions are met to enter
    - should_exit(): Determine if conditions are met to exit
    - calculate_position_size(): Calculate optimal position size
    """

    def __init__(self, config: StrategyConfig):
        self.config = config
        self.positions: Dict[str, Position] = {}
        self.signals: List[Signal] = []
        self.trade_history: List[Dict] = []
        self.is_running = False
        self.last_update = None

    @property
    @abstractmethod
    def strategy_type(self) -> str:
        """Return the strategy type identifier"""
        pass

    @abstractmethod
    def analyze(self, market_data: Dict[str, Any]) -> List[Signal]:
        """
        Analyze market data and generate trading signals.

        Args:
            market_data: Dict containing market information

        Returns:
            List of Signal objects
        """
        pass

    @abstractmethod
    def should_enter(self, signal: Signal, market_data: Dict[str, Any]) -> bool:
        """
        Determine if we should enter a position based on signal.

        Args:
            signal: The generated trading signal
            market_data: Current market data

        Returns:
            True if should enter, False otherwise
        """
        pass

    @abstractmethod
    def should_exit(self, position: Position, market_data: Dict[str, Any]) -> tuple[bool, str]:
        """
        Determine if we should exit a position.

        Args:
            position: Current position
            market_data: Current market data

        Returns:
            Tuple of (should_exit: bool, reason: str)
        """
        pass

    def calculate_position_size(self, signal: Signal, available_capital: float) -> float:
        """
        Calculate optimal position size using Kelly criterion.

        Args:
            signal: Trading signal with edge information
            available_capital: Available capital for trading

        Returns:
            Recommended position size in dollars
        """
        # Kelly formula: f* = (bp - q) / b
        # where b = odds, p = win probability, q = 1-p

        # Estimate win probability from confidence
        win_prob = 0.5 + (signal.confidence * 0.4)  # 50% to 90% range
        lose_prob = 1 - win_prob

        # Estimate odds (simplified)
        odds = 1.0  # Even odds for prediction markets

        kelly = (odds * win_prob - lose_prob) / odds
        kelly = max(0, kelly)  # Never negative

        # Apply Kelly fraction (user's risk preference)
        position_fraction = kelly * self.config.kelly_fraction

        # Apply signal's size recommendation
        position_fraction *= signal.size_recommendation

        # Calculate dollar amount
        position_size = available_capital * position_fraction

        # Cap at max position
        position_size = min(position_size, self.config.max_position)

        return round(position_size, 2)

    def check_exit_conditions(self, position: Position, market_data: Dict[str, Any]) -> tuple[bool, str]:
        """
        Check standard exit conditions (stop loss, take profit, etc.)

        Args:
            position: Current position
            market_data: Current market data

        Returns:
            Tuple of (should_exit: bool, reason: str)
        """
        pnl_percent = position.get_pnl_percent()

        # Check stop loss
        if self.config.stop_loss and pnl_percent <= -self.config.stop_loss:
            return True, f"Stop loss hit at {pnl_percent:.2f}%"

        # Check take profit
        if self.config.take_profit and pnl_percent >= self.config.take_profit:
            return True, f"Take profit hit at {pnl_percent:.2f}%"

        # Check trailing stop
        if self.config.trailing_stop and position.trailing_stop_trigger:
            # Trailing stop is active
            if pnl_percent <= position.trailing_stop_trigger - self.config.trailing_stop:
                return True, f"Trailing stop hit at {pnl_percent:.2f}%"
        elif self.config.trailing_stop and pnl_percent > 0:
            # Activate trailing stop when in profit
            if position.trailing_stop_trigger is None or pnl_percent > position.trailing_stop_trigger:
                position.trailing_stop_trigger = pnl_percent

        # Check time-based exit
        if self.config.time_exit_hours:
            hours_in_trade = (datetime.utcnow() - position.entry_time).total_seconds() / 3600
            if hours_in_trade >= self.config.time_exit_hours:
                return True, f"Time exit after {hours_in_trade:.1f} hours"

        # Check advanced exit conditions
        for condition_id, condition_config in self.config.advanced_exit_conditions.items():
            if not condition_config.get('enabled', False):
                continue

            value = condition_config.get('value', 0)

            if condition_id == 'edge-collapse':
                # Check if edge has collapsed
                current_edge = market_data.get('edge', 0)
                if current_edge < value:
                    return True, f"Edge collapsed below {value}%"

        # Check conditional rules
        for rule in self.config.conditional_rules:
            if self._check_conditional_rule(rule, position, market_data):
                action = rule.get('action', {})
                if action.get('type') == 'exit-position':
                    return True, f"Conditional rule triggered: {rule.get('trigger', {}).get('type')}"

        return False, ""

    def _check_conditional_rule(self, rule: Dict, position: Position, market_data: Dict) -> bool:
        """Check if a conditional rule is triggered"""
        trigger = rule.get('trigger', {})
        trigger_type = trigger.get('type')
        trigger_value = trigger.get('value', 0)

        pnl_percent = position.get_pnl_percent()
        hours_in_trade = (datetime.utcnow() - position.entry_time).total_seconds() / 3600

        if trigger_type == 'profit-reaches' and pnl_percent >= trigger_value:
            return True
        elif trigger_type == 'loss-reaches' and pnl_percent <= -trigger_value:
            return True
        elif trigger_type == 'time-elapsed' and hours_in_trade >= trigger_value:
            return True
        elif trigger_type == 'edge-drops':
            current_edge = market_data.get('edge', 0)
            if current_edge < trigger_value:
                return True

        return False

    def apply_conditional_rule_action(self, rule: Dict, position: Position):
        """Apply the action from a conditional rule"""
        action = rule.get('action', {})
        action_type = action.get('type')
        action_value = action.get('value', 0)

        if action_type == 'set-stop-loss':
            # Set stop loss at current price minus X%
            position.stop_loss = position.current_price * (1 - action_value / 100)
        elif action_type == 'set-trailing-stop':
            # Activate trailing stop
            position.trailing_stop = action_value
            position.trailing_stop_trigger = position.get_pnl_percent()
        elif action_type == 'set-take-profit':
            position.take_profit = position.current_price * (1 + action_value / 100)
        elif action_type == 'reduce-position':
            # Reduce position by X%
            position.size *= (1 - action_value / 100)

    def open_position(self, signal: Signal, size: float) -> Position:
        """Open a new position"""
        position = Position(
            id=str(uuid.uuid4()),
            market_id=signal.market_id,
            platform=signal.platform,
            side=signal.side,
            entry_price=signal.price,
            current_price=signal.price,
            size=size,
            entry_time=datetime.utcnow(),
            stop_loss=signal.price * (1 - self.config.stop_loss / 100) if signal.side == PositionSide.LONG else signal.price * (1 + self.config.stop_loss / 100),
            take_profit=signal.price * (1 + self.config.take_profit / 100) if signal.side == PositionSide.LONG else signal.price * (1 - self.config.take_profit / 100),
            metadata={'signal': signal.to_dict()},
        )

        self.positions[position.id] = position

        # Log trade
        self.trade_history.append({
            'type': 'open',
            'position_id': position.id,
            'market_id': signal.market_id,
            'platform': signal.platform,
            'side': signal.side.value,
            'price': signal.price,
            'size': size,
            'timestamp': datetime.utcnow().isoformat(),
            'reason': signal.reason,
        })

        return position

    def close_position(self, position: Position, reason: str) -> Dict:
        """Close a position and record the trade"""
        position.realized_pnl = position.unrealized_pnl

        trade_record = {
            'type': 'close',
            'position_id': position.id,
            'market_id': position.market_id,
            'platform': position.platform,
            'side': position.side.value,
            'entry_price': position.entry_price,
            'exit_price': position.current_price,
            'size': position.size,
            'pnl': position.realized_pnl,
            'pnl_percent': position.get_pnl_percent(),
            'entry_time': position.entry_time.isoformat(),
            'exit_time': datetime.utcnow().isoformat(),
            'reason': reason,
        }

        self.trade_history.append(trade_record)

        # Remove from active positions
        if position.id in self.positions:
            del self.positions[position.id]

        return trade_record

    def get_status(self) -> Dict:
        """Get current strategy status"""
        total_pnl = sum(p.unrealized_pnl for p in self.positions.values())
        realized_pnl = sum(t.get('pnl', 0) for t in self.trade_history if t['type'] == 'close')

        return {
            'strategy_type': self.strategy_type,
            'name': self.config.name,
            'is_running': self.is_running,
            'last_update': self.last_update.isoformat() if self.last_update else None,
            'open_positions': len(self.positions),
            'total_trades': len([t for t in self.trade_history if t['type'] == 'close']),
            'unrealized_pnl': total_pnl,
            'realized_pnl': realized_pnl,
            'positions': [p.to_dict() for p in self.positions.values()],
            'recent_signals': [s.to_dict() for s in self.signals[-10:]],
        }
